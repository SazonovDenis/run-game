## Запуск расчета кубов внутри приложения

Кубы обеспечивают согласованность в «конечном счёте» (eventual consistency), т.е. если
сервис расчета кубов запущен, то все изменения будут учтены в расчетах автоматически.

Если приложение использует данные из какого-либо куба, то после изменения данных
приложением (например, ввода замеров по скважине) может оказаться желательным обновить
этот куб сразу, в синхронном режиме (обновление в фоновом режиме в произойдет в любом
случае).

### Вариант 1.

Расчет по списку изменений. Будут расчитанны только явно указанные координаты.

Работает быстрее, чем вариант 2, т. к. расчитывает только указанные изменения.
Рекомендуется, если известен набор измененных координат и нужно расчитать только их.

~~~
// Что считаем
CoordList coords = CoordList.create()
for (Map rec : st) {
    Coord coord = Coord.create();
    coord.put("well", rec.get("well"))
    coords.add(coord);
}

// Создаем куб
CubeService cubeService = getModel().bean(CubeService)
Cube cube = cubeService.createCube("Cube_WellProd", mdb)

// Результат будем писать в БД
CalcResultStreamDb res = new CalcResultStreamDb(mdb, cube.getInfo())
res.open()

// Расчет и запись
cube.calc(coords, dt, dt, res)

// Запись остатка
res.close()
~~~

Вызов расчета из примера не вызовет расчета для всех зависимых кубов, изменения будут
учтены только для куба "Cube_WellProd".

### Вариант 2.

Расчет всех изменений. Будут учтены все изменения, сделанные на текущий момент.

Работает медленнее, чем вариант 1, т. к. расчитывает и чужие изменения. Рекомендуется,
если нужно учесть вообще все изменения (например, перед показом отчета).

~~~
WorkerService workerService = getModel().bean(WorkerService)
Worker worker = workerService.createWorker()
worker.calcAuditCube("Cube_WellProd", 0, 0, true)
~~~

Вызов расчета из примера гарантирует, что будут учтены изменения не только для куба
"Cube_WellProd", но и для всех зависимых кубов.
